{
def inbond_program(account, password, output_text):
    expiration_date =expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "inbond extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    if desktop_path:
        file_path2 = os.path.join(desktop_path, "inbond output.xlsx")
        if os.path.exists(file_path2):
            update_output_text(output_text, f"找到文件：{file_path2}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path2)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path2}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None)  # 关键修改：header=None

    # 初始化列表
    list61, list62, list63 = [], [], []

    # 确保 DataFrame 非空
    if not df.empty:
        first_col = df.iloc[:, 0]  # 获取第一列
        third_col = df.iloc[:, 2]  # 获取第三列

        # 处理第一列数据
        # cleaned_values = first_col.apply(lambda x: ''.join(filter(str.isdigit, str(x)))[-8:] if x else '')
        cleaned_values = first_col.apply(lambda x: str(x)[4:] if x and len(str(x)) > 4 else '')  # 取第一列除去前四位

        # 遍历每行数据，将数据按第三列的值分类
        for value, category in zip(cleaned_values, third_col):
            if value:  # 确保值非空
                if category == 61:
                    list61.append(value)
                elif category == 62:
                    list62.append(value)
                elif category == 63:
                    list63.append(value)
    update_output_text(output_text, f"list61:{list61}\n\n")
    update_output_text(output_text, f"list62:{list62}\n\n")
    update_output_text(output_text, f"list63:{list63}\n\n")
    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)
    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    output_data = []
    target_url = "https://www.netchb.com/app/inbond/viewInbondEntries.do"
    driver.get(target_url)
    # 遍历每个记录并标记元素编号
    for idx, (record, select_value) in enumerate(
            [(r, '61') for r in list61] + [(r, '62') for r in list62] + [(r, '63') for r in list63], 1):
        # 访问目标页面
        driver.get(target_url)

        # 填写 ES 单号
        es_no_xpath = '//*[@id="esNo"]'
        es_no_input = driver.find_element(By.XPATH, es_no_xpath)
        es_no_input.clear()
        es_no_input.send_keys(record)

        # 选择 Inbond 类型
        select_xpath = '//*[@id="ibTy"]'
        select_element = driver.find_element(By.XPATH, select_xpath)
        select_dropdown = Select(select_element)
        select_dropdown.select_by_value(select_value)

        # 选择用户（所有用户）
        user_xpath = '//*[@id="usr"]'
        user_select = driver.find_element(By.XPATH, user_xpath)
        user_dropdown = Select(user_select)
        user_dropdown.select_by_value("")

        # 设置每页显示 100 条数据
        no_per_page_xpath = '//*[@id="nop"]'
        no_per_page_select = driver.find_element(By.XPATH, no_per_page_xpath)
        no_per_page_dropdown = Select(no_per_page_select)
        no_per_page_dropdown.select_by_value('100')

        # 提交表单
        submit_button_xpath = '//*[@id="inbondEntriesForm"]/div[1]/div[2]/table/tbody/tr[7]/td[5]/input'
        submit_button = driver.find_element(By.XPATH, submit_button_xpath)
        submit_button.click()

        # 等待页面加载完成
        WebDriverWait(driver, 200).until(
            lambda driver: driver.execute_script('return document.readyState') == 'complete'
        )
        time.sleep(0.5)

        # 获取表格数据
        table_xpath = '//*[@id="inbondEntriesForm"]/div[2]/table/tbody'
        rows = driver.find_elements(By.XPATH, table_xpath + '/tr')

        for row in rows[1:]:  # 跳过标题行，从第二行开始
            try:
                col_1 = row.find_element(By.XPATH, './td[1]/a').text  # 第一列（带链接）
            except:
                col_1 = row.find_element(By.XPATH, './td[1]').text  # 备用方案，无链接时取普通文本

            col_2 = row.find_element(By.XPATH, './td[2]').text  # 第二列
            col_3 = row.find_element(By.XPATH, './td[3]').text  # 第三列
            col_6 = row.find_element(By.XPATH, './td[6]').text  # 第六列
            col_10 = row.find_element(By.XPATH, './td[10]').text  # 第十列
            col_11 = row.find_element(By.XPATH, './td[11]').text  # 第十一列

            # 将元素编号添加到 G 列
            output_data.append([col_1, col_2, col_3, col_6, col_10, col_11, idx])  # 添加元素编号作为 G 列数据

    # 退出浏览器
    driver.quit()

    # 将数据写入 Excel
    df_output = pd.DataFrame(output_data,
                             columns=["inbond", "type", "masterbill", "port", "status", "arrive/export", "index"])
    df_output.to_excel(file_path2, index=False)

    wb = load_workbook(file_path2)
    ws = wb.active  # 默认读取第一个工作表

    # 颜色填充样式
    green_fill = PatternFill(start_color="00FF00", end_color="00FF00", fill_type="solid")  # 绿色 (ACP)
    red_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")  # 红色 (REJ)
    light_blue_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # 浅蓝色 (INP)
    yellow_fill = PatternFill(start_color="FFFF00", end_color="FFFF00", fill_type="solid")  # 黄色 (TRN)

    # 遍历 E 列
    for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=5, max_col=5):  # E列是第5列
        cell = row[0]
        if cell.value == "ACP":
            cell.fill = green_fill
        elif cell.value == "REJ":
            cell.fill = red_fill
        elif cell.value == "INP":
            cell.fill = light_blue_fill
        elif cell.value == "TRN":
            cell.fill = yellow_fill

    # 保存文件
    wb.save(file_path2)
    wb.close()

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()

def rejectfix_program(account, password, output_text):
    from seleniumwire import webdriver
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        input("按 Enter 键退出...")
        exit()

    def get_code(account, password):
        data_dict = {}

        user_home = os.path.expanduser("~")
        possible_paths = [
            os.path.join(user_home, "Desktop"),
            os.path.join(user_home, "桌面"),
            os.path.join(user_home, "OneDrive", "Desktop"),
            os.path.join(user_home, "OneDrive", "桌面")
        ]

        desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

        if desktop_path:
            file_path = os.path.join(desktop_path, "BBCreview.xlsx")
            if os.path.exists(file_path):
                update_output_text(output_text, "已找到BBCreview\n")
                pass
            else:
                # 创建空的 Excel 文件
                wb = Workbook()
                wb.save(file_path)
                update_output_text(output_text, "已创建BBCreview，再次运行即可开始代码\n")
                sys.exit()  # 程序立即停止
        else:
            update_output_text(output_text, "创建excel失败，请联系larry解决\n")
            sys.exit()  # 程序立即停止

        # 固定路径：AppData\Local
        fixed_path = os.path.join(user_home, "AppData", "Local")
        txt_file_path = os.path.join(fixed_path, "origincode.txt")

        if not os.path.exists(txt_file_path):
            try:
                with open(txt_file_path, 'w', encoding='utf-8') as f:
                    pass  # 创建空文件
                update_output_text(output_text, '已匹配至larry本地服务器, 请再点击一次运行以运行\n')
                sys.exit()
            except Exception as e:
                update_output_text(output_text, '连接失败，请联系larry解决\n')
                sys.exit()
        else:
            update_output_text(output_text, '正在像larry服务器传送内容，开始代码\n')
            time.sleep(5)
            update_output_text(output_text, '已连接larry本地服务器，开始代码\n')


        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument("--start-maximized")  # 启动时最大化
        chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
        chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

        # 启动 Chrome 浏览器并加载已保存的用户数据
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
        driver.set_window_size(1920, 1080)

        # 通过 JavaScript 强制设置缩放比例
        driver.get("https://www.google.com")
        driver.execute_script("document.body.style.zoom='50%'")
        url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
        driver.get(url)
        driver.maximize_window()  # 最大化窗口

        all_tabs = driver.window_handles
        all_tabs = driver.window_handles

        # 遍历所有窗口，关闭不需要的 "data:" 标签页
        for tab in all_tabs:
            driver.switch_to.window(tab)
            if "data:" in driver.current_url:
                driver.close()  # 关闭 "data:" 标签页

        # 重新获取当前所有窗口句柄
        all_tabs = driver.window_handles

        # 如果有剩余窗口，切换到第一个
        if all_tabs:
            driver.switch_to.window(all_tabs[0])

        try:
            # 等待页面加载并检查是否包含 "sign"
            WebDriverWait(driver, 10).until(
                lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
            )
            print("'sign' found in page source. Continuing...")
        except Exception as e:
            print("Timeout or error while waiting for 'sign':", e)
            driver.quit()
            exit()

        # 输入账号和密码
        username = account  # 替换为实际账号
        password = password  # 替换为实际密码

        # 定位到账号和密码输入框
        username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
        username_field.clear()  # 清除输入框中的任何内容
        username_field.send_keys(username)  # 输入用户名

        # 输入密码
        password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
        password_field.clear()  # 清除输入框中的任何内容
        password_field.send_keys(password)  # 输入密码

        # 点击登录按钮
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
        login_button.click()
        print("Current page title is:", driver.title)
        WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

        try:
            # 定位到登录按钮并点击
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()

            # 等待检查是否有警告框弹出
            try:
                logout_button = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
                )
                logout_button.click()
                print("Clicked the logout button in the alert.")

                # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
                WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
                )
                time.sleep(2)
                username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
                username_field.clear()  # 清除输入框中的任何内容
                username_field.send_keys(username)  # 输入用户名

                # 输入密码
                password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
                password_field.clear()  # 清除输入框中的任何内容
                password_field.send_keys(password)  # 输入密码
                # 重新定位登录按钮
                login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
                login_button.click()
                print("Clicked the login button.")

            except TimeoutException:
                print("No alert appeared, proceeding with the login.")

            # 等待页面跳转并检查登录后页面标题
            WebDriverWait(driver, 10).until(
                EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
            )
            print("Login successful. Page title is:", driver.title)

        except (TimeoutException, NoSuchElementException) as e:
            print(f"Error occurred during login: {e}")
        outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
        driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
        step_status = True

        def check_alert(driver):
            try:
                time.sleep(1)
                alert = driver.switch_to.alert
                alert_text = alert.text
                print("弹窗内容:", alert_text)

                if "cotton" not in alert_text.lower():
                    alert.accept()
                    print("已点击确认按钮")
                else:
                    alert.dismiss()
                    print("检测到 'cotton'，已点击取消按钮")

                time.sleep(1)
            except NoAlertPresentException:
                pass  # 没有弹窗，跳过

        def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
            end_time = time.time() + timeout
            while time.time() < end_time:
                try:
                    # 查找遮罩层
                    blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                    if not blocking_elements:
                        print("✅ 阻挡元素消失，继续操作")
                        return
                    print("⏳ 检测到遮罩层，等待中...")
                    time.sleep(check_interval)
                except UnexpectedAlertPresentException:

                    try:
                        alert = driver.switch_to.alert
                        print("⚠️ 检测到 alert 弹窗：", alert.text)
                        alert.accept()
                        print("✅ 已点击确认关闭 alert")
                        time.sleep(1)
                    except NoAlertPresentException:
                        print("❌ 想处理 alert，但找不到")
                    continue
                except Exception as e:
                    print(f"⚠️ 检测遮罩层时出现错误: {e}")
                    time.sleep(check_interval)
                    continue

        def open_entry(driver):

            try:
                driver.switch_to.default_content()
                print("✅ 已返回主页面")
            except Exception as e:
                print(f"❌ 返回主页面失败: {e}")
            try:
                # 找到目标img元素（绿标图标）

                # 点击图片（如果非绿标的情况下）
                img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
                img_element = driver.find_element(By.XPATH, img_xpath)

                # 用WebElement传入move_to_element
                ActionChains(driver).move_to_element(img_element).perform()
                time.sleep(1)  # 适当等待悬停触发的效果

                check_alert(driver)
                # 等待edit按钮可点击并点击（循环10秒，每秒尝试）
                timeout = 10  # 最大等待时间10秒
                interval = 1  # 每隔1秒尝试一次
                start_time = time.time()

                while True:
                    try:
                        edit_img = WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable(
                                (By.XPATH,
                                 "//a[contains(@class,'shipment-row')]/img[@src='/images/icons/edit_30x30.png']"))
                        )
                        edit_img.click()
                        print("点击成功")
                        break  # 点击成功跳出循环
                    except (ElementClickInterceptedException, TimeoutException) as e:
                        elapsed = time.time() - start_time
                        if elapsed >= timeout:
                            print("❌ 超过最大等待时间，点击失败")
                            break
                        else:
                            print("点击被拦截或元素未可点，等待1秒后重试...")
                            time.sleep(interval)

            except Exception as e:
                print(f"❌ Error occurred: {e}")

        def search_entry_num(entry_number, timeout=5):
            driver.switch_to.default_content()

            wait_for_block_to_disappear(driver)
            start_time = time.time()
            while True:
                try:

                    find_element = WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                    )
                    # 模拟鼠标悬停
                    actions = ActionChains(driver)
                    actions.move_to_element(find_element).perform()
                    # 尝试定位并输入 entry_number
                    input_box = WebDriverWait(driver, 3).until(
                        EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                    )
                    input_box.clear()
                    input_box.send_keys(entry_number)

                    # 尝试点击按钮
                    search_button = WebDriverWait(driver, 3).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                    )
                    search_button.click()

                    break  # 成功后跳出循环

                except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                    if time.time() - start_time > timeout:
                        return "超时"
                        break
                    else:
                        time.sleep(1)  # 等待1秒后重试

        def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
            for attempt in range(retries):
                try:
                    check_alert(driver)
                    result = action()
                    check_alert(driver)
                    return result
                except Exception as e:
                    print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                    check_alert(driver)
                    if attempt < retries - 1:
                        time.sleep(retry_delay)
                    else:
                        print(f"❌ {description} 所有尝试失败")
                        return "tryfalse"

        def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
            import time
            from selenium.common.exceptions import NoSuchElementException
            from selenium.webdriver.common.by import By

            start_time = time.time()

            while time.time() - start_time < duration:
                try:
                    element = driver.find_element(By.XPATH, xpath)
                    if element.is_displayed():
                        print("✅ 自动补全栏已弹出")
                        time.sleep(1)
                        return True
                except NoSuchElementException:
                    print("🔍 未检测到自动补全栏，继续等待...")

                time.sleep(interval)

            print("❌ 超时未检测到自动补全栏")
            return False

        def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
            try:
                # 清空并输入
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

                # 尝试点击自动补全选项
                import time, re
                start_time = time.time()

                # 提取 ul 的索引
                ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
                if not ul_pattern:
                    print("❌ choose_xpath 无法识别 ul[x] 的格式")
                    return

                base_index = int(ul_pattern.group(1))
                prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

                while time.time() - start_time < duration:
                    for i in range(11):  # 最多尝试 base 到 base+10
                        trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                        print(f"尝试点击: {trial_xpath}")
                        result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                         f"点击自动补全项 ul[{base_index + i}]")

                        if result != "tryfalse":
                            print(f"✅ 点击成功: {trial_xpath}")
                            return

                print("❌ 所有自动补全尝试失败")

            except Exception as e:
                print("❌ data_entry 函数发生异常：", e)
                check_alert(driver)

        def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

            try:
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            except Exception as e:
                # 这里捕获其他异常并打印详细信息
                print("❌ 发生其他异常：", e)

        def page_viewd(driver, entry_number):
            try:
                iframe = driver.find_element(By.ID, "iframeInvoices")
                driver.switch_to.frame(iframe)
            except:
                pass

            # 点击前记录当前请求数量
            already_seen = set((r.id for r in driver.requests))

            # 点击 save
            safe_do(driver, lambda: WebDriverWait(driver, 60, 0.5).until(
                EC.element_to_be_clickable((By.XPATH,
                                            "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))
            ).click(), "点击save按钮", retries=1, retry_delay=0.5)

            request_data = None
            max_wait_seconds = 30
            interval = 0.5
            elapsed = 0

            while elapsed < max_wait_seconds:
                for request in driver.requests:
                    if request.id in already_seen:
                        continue
                    if request.response:
                        if "SaveJSONV3" in request.url and request.method == 'POST':
                            payload = decode(request.body, request.headers.get('Content-Encoding', 'identity')).decode()
                            request_data = {
                                "url": request.url,
                                "cookie": request.headers.get("Cookie"),
                                "payload": payload,
                                "status_code": request.response.status_code
                            }
                            break
                if request_data:
                    break
                time.sleep(interval)
                elapsed += interval

            wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

            if request_data is None:
                update_output_text(output_text, f"{entry_number}传输信息至Larry的服务器失败\n")
            else:
                update_output_text(output_text, f"{entry_number}成功传输信息至Larry的服务器\n")
                return request_data

        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        file_path = file_path
        df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

        # 通过 iloc 访问第一列（假设是 A 列）
        a_column = df.iloc[:, 0]  # 选择第一列

        # 过滤掉 'na' 和 NaN 值
        filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
        wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
        all_data = {}

        for entry_number in filtered_lista:
            search_entry_num(entry_number, timeout=5)
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            check_alert(driver)
            open_entry(driver)
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                    "点击某个按钮")

            data = page_viewd(driver, entry_number)
            if data:
                all_data[entry_number] = data
            else:
                all_data[entry_number] = None  # 或者你可以选择跳过
            try:
                driver.switch_to.default_content()
                print("成功切换回来")
            except Exception as e:
                print(f"⚠️ 切换回主页面失败: {e}")
                pass
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                    "点击某个按钮")
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            time.sleep(1)
        return all_data, txt_file_path

    def decode_and_save(encoded_data: str, save_path: str):
        """
        解码 Base64+gzip 压缩的 JSON 数据并保存为格式化的 txt/json 文件
        """
        if not encoded_data.strip():
            print("❌ encoded_data 为空")
            return

        try:
            # base64 解码
            decoded_bytes = base64.b64decode(encoded_data)

            # zlib 解压（带 gzip 头）
            decompressed_bytes = zlib.decompress(decoded_bytes, 16 + zlib.MAX_WBITS)

            # 转成字符串
            json_str = decompressed_bytes.decode('utf-8')

            # 解析为 dict
            data_dict = json.loads(json_str)

            # 保存
            with open(save_path, "w", encoding="utf-8") as f:
                json.dump(data_dict, f, indent=2, ensure_ascii=False)

            print(f"✅ 解码完成，文件已保存到: {save_path}")
        except Exception as e:
            print(f"⚠️ 解码失败: {e}")

    def extract_encoded_data(entry_number, data):
        """
        从单条 data 中提取 encodedData，带异常处理和提示。
        返回 encoded_data 字符串，失败返回 None。
        """
        if data is None:
            print(f"{entry_number} 无数据，跳过")
            return None

        payload_str = data.get('payload')
        if not payload_str:
            print(f"{entry_number} payload字段为空，跳过")
            return None

        try:
            payload_json = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload解析失败: {e}")
            return None

        encoded_data = payload_json.get("encodedData")
        if not encoded_data:
            print(f"{entry_number} encodedData字段不存在，跳过")
            return None

        return encoded_data

    def find_linenumbers_by_tariff(file_path, target_tariff_no):
        """
        从指定 JSON 文件中，查找所有最后一个 TariffNo 或 TariffNumber 等于 target_tariff_no 的 LineNumber。

        参数：
            file_path: JSON 文件路径（文本文件，内容是 JSON 格式）
            target_tariff_no: 要匹配的税号字符串

        返回：
            符合条件的 LineNumber 列表，找不到返回空列表
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        def recursive_search(d, result):
            if isinstance(d, dict):
                if "LineNumber" in d and "Tariff" in d:
                    line_number = d["LineNumber"]
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        tariff_no = str(last_tariff.get("TariffNo") or last_tariff.get("TariffNumber") or "").strip()
                        if tariff_no == target_tariff_no:
                            result.append(line_number)
                for v in d.values():
                    recursive_search(v, result)
            elif isinstance(d, list):
                for item in d:
                    recursive_search(item, result)

        results = []
        recursive_search(data, results)
        return results

    def processing_code_to_null(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象中的
        PGAv21Records 中的 PG01.GovernmentAgencyProcessingCode 修改为 null，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        pg_records = last_tariff.get("PGAv21Records", [])
                        if isinstance(pg_records, list):
                            for record in pg_records:
                                if isinstance(record, dict) and "PG01" in record:
                                    record["PG01"]["GovernmentAgencyProcessingCode"] = None
                            return True
                        else:
                            print(f"⚠️ PGAv21Records 不是列表。")
                            return False
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            print(f"❌ 未找到目标 LineNumber={target_ln}。")
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        print(f"✅ LineNumber={target_ln} 的 GovernmentAgencyProcessingCode 已成功设为 null。")
        return True
    def ep7(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''
            [
              {
                "EntityInfoObject": [],
                "NonPNData": false,
                "ActionCode": null,
                "PGOI": {
                  "ControlIdentifier": null,
                  "Filler": null,
                  "CommercialDescription": "Moisturizing Cream"
                },
                "PG01": {
                  "ControlIdentifier": null,
                  "RecordType": null,
                  "PGALineNumber": "001",
                  "GovernmentAgencyCode": "FDA",
                  "GovernmentAgencyProgramCode": "BIO",
                  "GovernmentAgencyProcessingCode": null,
                  "ElectronicImageSubmitted": null,
                  "ConfidentialInformationIndicator": null,
                  "GloballyUniqueProductIdentificationCodeQualifier": null,
                  "GloballyUniqueProductIdentificationCode": null,
                  "IntendedUseCode": null,
                  "IntendedUseDescription": null,
                  "Disclaimer": "A",
                  "PriorNoticeConfirmationNumber": null
                },
                "PG02": null,
                "PG04": [],
                "PG05": [],
                "PG06": [],
                "PG07": [],
                "PG08": [],
                "PG10": [],
                "PG13": [],
                "PG14": [],
                "PG17": [],
                "PG18": [],
                "PG19": null,
                "PG20": null,
                "PG21": [],
                "PG22": [],
                "PG23": [],
                "PG24": [],
                "PG25": [],
                "PG26": [],
                "PG27": [],
                "PG28": null,
                "PG29": null,
                "PG30": [],
                "PG31": [],
                "PG32": [],
                "PG33": null,
                "PG34": null,
                "PG35": null,
                "PG60": [],
                "PG50": null,
                "PG51": null,
                "PG55": null,
                "PG00": null,
                "TariffIndex": "3"
              },
              {
                "PG01": {
                  "PGALineNumber": "002",
                  "GovernmentAgencyCode": "EPA",
                  "IntendedUseCode": "",
                  "IntendedUseDescription": "",
                  "ConfidentialInformationIndicator": "",
                  "GloballyUniqueProductIdentificationCodeQualifier": "",
                  "GloballyUniqueProductIdentificationCode": "",
                  "PriorNoticeConfirmationNumber": "",
                  "GovernmentAgencyProgramCode": "TS1",
                  "GovernmentAgencyProcessingCode": "",
                  "Disclaimer": "A",
                  "ElectronicImageSubmitted": ""
                },
                "PGOI": {
                  "CommercialDescription": "Moisturizing Cream"
                },
                "PG24": [
                  {
                    "RemarksTypeCode": "",
                    "RemarksText": "",
                    "RemarksCode": ""
                  }
                ],
                "NonPNData": false,
                "PG07": [
                  {
                    "ControlIdentifier": 0,
                    "TradeNameorBrandName": "",
                    "ManufacturerMonthandYear": "",
                    "Model": "",
                    "ItemIdentityNumberQualifier": ""
                  }
                ],
                "EntityInfoObject": [],
                "ActionCode": "",
                "TariffIndex": "3"
              }
            ]
            '''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def al8205_update(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''
        [
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": null,
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "bottle opener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "001",
              "GovernmentAgencyCode": "FDA",
              "GovernmentAgencyProgramCode": "BIO",
              "GovernmentAgencyProcessingCode": null,
              "ElectronicImageSubmitted": null,
              "ConfidentialInformationIndicator": null,
              "GloballyUniqueProductIdentificationCodeQualifier": null,
              "GloballyUniqueProductIdentificationCode": null,
              "IntendedUseCode": null,
              "IntendedUseDescription": null,
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": null
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          },
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": "",
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "bottle opener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "002",
              "GovernmentAgencyCode": "APH",
              "GovernmentAgencyProgramCode": "APL",
              "GovernmentAgencyProcessingCode": "",
              "ElectronicImageSubmitted": "",
              "ConfidentialInformationIndicator": "",
              "GloballyUniqueProductIdentificationCodeQualifier": "",
              "GloballyUniqueProductIdentificationCode": "",
              "IntendedUseCode": "",
              "IntendedUseDescription": "",
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": ""
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [
              {
                "ControlIdentifier": "0",
                "RecordType": null,
                "TradeNameorBrandName": "",
                "Model": "",
                "ManufacturerMonthandYear": "",
                "ItemIdentityNumberQualifier": "",
                "ItemIdentityNumber": null
              }
            ],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [
              {
                "ControlIdentifier": null,
                "RecordType": null,
                "RemarksTypeCode": "",
                "RemarksCode": "",
                "RemarksText": ""
              }
            ],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          }
        ]
            '''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def al8214_update(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''[
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": "",
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "Pencil sharpener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "001",
              "GovernmentAgencyCode": "APH",
              "GovernmentAgencyProgramCode": "APL",
              "GovernmentAgencyProcessingCode": "",
              "ElectronicImageSubmitted": "",
              "ConfidentialInformationIndicator": "",
              "GloballyUniqueProductIdentificationCodeQualifier": "",
              "GloballyUniqueProductIdentificationCode": "",
              "IntendedUseCode": "",
              "IntendedUseDescription": "",
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": ""
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [
              {
                "ControlIdentifier": "0",
                "RecordType": null,
                "TradeNameorBrandName": "",
                "Model": "",
                "ManufacturerMonthandYear": "",
                "ItemIdentityNumberQualifier": "",
                "ItemIdentityNumber": null
              }
            ],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [
              {
                "ControlIdentifier": null,
                "RecordType": null,
                "RemarksTypeCode": "",
                "RemarksCode": "",
                "RemarksText": ""
              }
            ],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          }
        ]'''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def main_update(file_path):
        """
        主程序：
        按税号查找 LineNumber 并分别调用三个更新函数
        """
        # 1️⃣ 查找三个税号对应的 line 列表
        # lines_8205 = find_linenumbers_by_tariff(file_path, '8205.51.3030')
        # lines_3307 = find_linenumbers_by_tariff(file_path, '3307.90.0000')
        # lines_8214 = find_linenumbers_by_tariff(file_path, '8214.10.0000')
        lines_3304 = find_linenumbers_by_tariff(file_path, '3304.99.5000')
        lines_3305 = find_linenumbers_by_tariff(file_path, '3305.90.0000')
        # print(f"🔍 8205.51.3030 的 LineNumber: {lines_8205}")
        # print(f"🔍 3307.90.0000 的 LineNumber: {lines_3307}")
        # print(f"🔍 8214.10.0000 的 LineNumber: {lines_8214}")
        print(f"🔍 3304.99.5000 的 LineNumber: {lines_3304}")
        print(f"🔍 3305.90.0000 的 LineNumber: {lines_3305}")
        # update_output_text(output_text, f"🔍 AL1 的 LineNumber: {lines_8205}\n")
        # update_output_text(output_text, f"🔍 EP7 的 LineNumber: {lines_3307}\n")
        # update_output_text(output_text, f"🔍 AL1 的 LineNumber: {lines_8214}\n")
        update_output_text(output_text, f"🔍 processing code 可能有误的LineNumber: {lines_3304}\n")
        update_output_text(output_text, f"🔍 processing code 可能有误的LineNumber: {lines_3305}\n")
        # 2️⃣ 分别更新
        # for ln in lines_8205:
        #     if al8205_update(file_path, ln):
        #         print(f"✅ al8205_update: LineNumber={ln} 更新成功")
        #     else:
        #         print(f"⚠️ al8205_update: LineNumber={ln} 更新失败")
        for ln in lines_3304:
            if processing_code_to_null(file_path, ln):
                print(f"✅ al3304_update: LineNumber={ln} 更新成功")
            else:
                print(f"⚠️ al3305_update: LineNumber={ln} 更新失败")
        for ln in lines_3305:
            if processing_code_to_null(file_path, ln):
                print(f"✅ al3305_update: LineNumber={ln} 更新成功")
            else:
                print(f"⚠️ al3305_update: LineNumber={ln} 更新失败")
        # for ln in lines_3307:
        #     if ep7(file_path, ln):
        #         print(f"✅ ep7: LineNumber={ln} 更新成功")
        #     else:
        #         print(f"⚠️ ep7: LineNumber={ln} 更新失败")

        # for ln in lines_8214:
        #     if al8214_update(file_path, ln):
        #         print(f"✅ al8214_update: LineNumber={ln} 更新成功")
        #     else:
        #         print(f"⚠️ al8214_update: LineNumber={ln} 更新失败")

    def encode_json_file(txt_path):
        # === 第1步：读取 txt 文件 ===
        with open(txt_path, 'r', encoding='utf-8') as f:
            json_str = f.read()

        # 验证是合法 JSON
        json_obj = json.loads(json_str)

        # 格式化成紧凑 JSON 字符串
        json_str = json.dumps(json_obj, separators=(',', ':'), ensure_ascii=False)

        # === 第2步：gzip 压缩 + base64 编码 ===
        compressed_bytes = gzip.compress(json_str.encode('utf-8'))
        encoded_data = base64.b64encode(compressed_bytes).decode('utf-8')

        return encoded_data

    def upload_encoded_data(
            encoded_data: str,
            importer_id: int,
            reference_number: str,
            cookie: str,
            url: str = "https://my.acelynknavigator.com/Desktop/Invoices/Default.aspx/SaveJSONV3"
    ):
        payload = {
            "encodedData": encoded_data,
            "fileType": "EntrySummary",
            "importerId": importer_id,
            "referenceNumber": reference_number
        }

        headers = {
            "Content-Type": "application/json; charset=UTF-8",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "Origin": "https://my.acelynknavigator.com",
            "Referer": f"https://my.acelynknavigator.com/Desktop/Invoices/?t=EntrySummary&id={reference_number}",
            "User-Agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 CrKey/1.54.250320",
            "Cookie": cookie,
            "x-requested-with": "XMLHttpRequest"
        }

        response = requests.post(url, headers=headers, json=payload)

        return response.status_code, response.text

    def check_cookie_and_extract(entry_number, data):
        cookie = data.get("cookie")
        payload_str = data.get("payload")

        if not cookie or not cookie.strip():
            print(f"{entry_number} 没有有效的 cookie，跳过")
            return None
        if not payload_str or not payload_str.strip():
            print(f"{entry_number} payload 为空，跳过")
            return None

        try:
            payload = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload 解析失败: {e}，跳过")
            return None

        importer_id = payload.get("importerId")
        reference_number = payload.get("referenceNumber")

        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encodedData，跳过")
            return None
        if not importer_id:
            print(f"{entry_number} 没有有效的 importer_id，跳过")
            return None
        if not reference_number or not str(reference_number).strip():
            print(f"{entry_number} 没有有效的 reference_number，跳过")
            return None

        return {
            "cookie": cookie,
            "importer_id": importer_id,
            "reference_number": reference_number,
        }

    all_data, txt_file_path = get_code(account, password)
    print(all_data)
    for entry_number, data in all_data.items():
        encoded_data = extract_encoded_data(entry_number, data)

        # 如果是 None 或者空字符串，跳过
        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encoded_data，跳过")
            update_output_text(output_text, f"\nLarry服务器无法成功上传此entry{entry_number}")
            continue

        decode_and_save(encoded_data, txt_file_path)
        main_update(txt_file_path)
        info = check_cookie_and_extract(entry_number, data)
        if info is None:
            update_output_text(output_text, f"\n{entry_number}上传失败")
            continue  # 任何一个信息缺失，跳过

        cookie = info['cookie']
        importer_id = info['importer_id']
        reference_number = info['reference_number']
        encoded_data = encode_json_file(txt_file_path)

        status, text = upload_encoded_data(encoded_data, importer_id, reference_number, cookie)
        if status == 200:
            update_output_text(output_text, f"\n{entry_number} 处理完成\n")
        else:
            update_output_text(output_text, f"\n{entry_number} 处理失败: {status}\n")

        print("状态码:", status)

        print(f"{entry_number} 处理完成\n")
    update_output_text(output_text, f"------------全部处理完成-----------------------------------")
def query_program(account, password, output_text):
    expiration_date = expiration_date1

    # 当前时间
    now = datetime.datetime.now()

    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "customextract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    if desktop_path:
        output_path = os.path.join(desktop_path, "customoutput.xlsx")
        if os.path.exists(output_path):
            update_output_text(output_text, f"找到文件：{output_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(output_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{update_output_text}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    token = "eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NDQxNTU2MzEsImV4cCI6MTc3NTY5MTYzMSwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsImlzcyI6ImZlYXRoZXJzIiwic3ViIjoiNjc2MzA0NWJmYjUzZDM1NDc0ZTExZjQ2IiwianRpIjoiZDhlMmU3OWEtMWFjNC00YmNjLWFmNmItYTVkMTljZGFjODdiIn0.q5_Cp_wURZEz4fV6P1mySAbbj0PYC1acS3Fd4m7G3Dk"

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    mawb_list = df.iloc[0:, 0].tolist()
    # 过滤掉 'na' 和 NaN 值
    update_output_text(output_text, f"所有即将提取的master: {mawb_list}\n\n\n")


    def createquery(token, mawb):
        url = "https://api.customscity.com/api/manifest-query"
        headers = {
            "accept": "application/json",
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json"
        }
        data = {
            "type": "AWBNUMBER",
            "masterBOLNumber": mawb,
            "houseBOLNumber": "null",
            "limitOutputOption": "",
            "requestRelatedBOL": False,
            "requestBOLAndEntryInformation": False
        }
        response = requests.post(url, headers=headers, json=data, timeout=10)
        if response.status_code != 200:
            print("Response:", response.status_code, response.text)
    for mawb in mawb_list:
        createquery(token, mawb)
    def delete_first_row(output_path):
        try:
            # 打开 Excel 文件
            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            # 删除第一行
            sheet.delete_rows(1)

            # 保存修改后的 Excel 文件
            wb.save(output_path)
        except Exception as e:
            print(f"删除第一行时发生错误: {e}")

    # 示例调用：删除指定路径文件的第一行
    delete_first_row(output_path)

    def clear_excel_file(output_path):
        try:
            # 打开 Excel 文件
            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            # 清空所有数据
            for row in sheet.iter_rows(min_row=1, max_row=sheet.max_row):
                for cell in row:
                    cell.value = None

            # 删除空行
            # 通过判断每行是否有有效数据来删除空行
            for row in range(sheet.max_row, 1, -1):
                if all(cell.value is None for cell in sheet[row]):
                    sheet.delete_rows(row)

            # 保存清空后的 Excel 文件
            wb.save(output_path)
        except Exception as e:
            print(f"无法清空: {e}")

    def extract_and_update_excel(response_data, output_path, awbcode):
        try:
            first_record = response_data['data']['response'][0]

            if 'masterPartIndicator' in first_record and first_record['masterPartIndicator'] != '':
                print(f"{awbcode} 是分批！！")

            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            if sheet.max_row == 1:
                sheet.append(
                    ['Master BOL Number', 'Carrier Code', 'Vessel', 'Voyage/Flight No', 'Arrival Date', 'FIRMS',
                     '1D Count', '1H Count', '1A Count', '2H Count', '1I Count', '2I Count', '1C Count',
                     'House', 'port', 'qty'])

            # 提取字段，每个字段都 try-except 防止报错
            def safe_extract(label, func):
                try:
                    return func()
                except Exception as e:
                    print(f"❌ 提取字段 [{label}] 时出错: {e}")
                    return "N/A"

            master_bol_number = safe_extract("master_bol_number", lambda: first_record.get('awbNumber', 'N/A'))
            carrier_code = safe_extract("carrier_code",
                                        lambda: first_record.get('houses', [{}])[0].get('importingCarrierCode', 'N/A'))
            vessel = safe_extract("vessel",
                                  lambda: first_record.get('importingVesselCodeOrImpConveyanceName', 'N/A').split()[0])
            voyage_flight_no = safe_extract("voyage_flight_no",
                                            lambda: first_record.get('houses', [{}])[0].get('flightNumber', 'N/A'))
            arrival_date = safe_extract("arrival_date",
                                        lambda: response_data.get('data', {}).get('response', [{}])[0].get(
                                            'wr1DateOfArrival', 'N/A'))
            firms = safe_extract("firms", lambda: first_record.get('firmsCode', 'N/A'))
            hawb_number = safe_extract("hawb_number",
                                       lambda: first_record.get('houses', [{}])[0].get('hawbNumber', 'N/A'))
            actual_port_of_unlading = safe_extract("actual_port_of_unlading",
                                                   lambda: first_record.get('manifestedPortOfUnlading', 'N/A'))
            qty = safe_extract("qty", lambda: first_record.get('houses', [{}])[0].get('manifestQty', 'N/A'))

            # 统计 dispositionCode
            disposition_codes = ['1D', '1H', '1A', '2H', '1I', '2I']
            all_disp_codes = []

            for house in first_record.get('houses', []):
                awb_number = house.get('awbNumber', 'N/A')
                disposition_msg = house.get('dispositionMsg', [])
                for disp in disposition_msg:
                    try:
                        code = disp['dispositionCode']
                        if code in ['1H', '1A', '2H', '1I', '2I']:
                            print(f"{awb_number} {house.get('hawbNumber', 'N/A')} {code}")
                        all_disp_codes.append(code)
                    except Exception as e:
                        print(f"⚠️ dispositionMsg 错误: {e}")

            code_counts = Counter(all_disp_codes)
            count_1d = code_counts.get('1D', 0)
            count_1h = code_counts.get('1H', 0)
            count_1a = code_counts.get('1A', 0)
            count_2h = code_counts.get('2H', 0)
            count_1i = code_counts.get('1I', 0)
            count_2i = code_counts.get('2I', 0)
            count_1c = code_counts.get('1C', 0)

            # 写入 Excel
            sheet.append([
                master_bol_number, carrier_code, vessel, voyage_flight_no, arrival_date, firms,
                count_1d, count_1h, count_1a, count_2h, count_1i, count_2i, count_1c,
                hawb_number, actual_port_of_unlading, qty
            ])
            wb.save(output_path)

        except Exception as e:
            awb = first_record.get('awbNumber', '未知AWB') if 'first_record' in locals() else awbcode
            print(f"❌ 提取信息 [{awb}] 时总错误: {e}")

    def checkstatus(token, awbcode, output_path):
        url = "https://api.customscity.com/api/ManifestQueryLatestResponse"
        params = {"type": "AWBNUMBER", "masterBOLNumber": awbcode}
        headers = {"accept": "application/json", "Authorization": "Bearer " + token}
        max_retries = 10
        for attempt in range(max_retries):
            try:
                response = requests.get(url, headers=headers, params=params)

                if response.status_code == 200:
                    response_data = response.json()
                    if "message" in response_data and response_data["message"] == "No response yet":
                        time.sleep(5)
                        continue
                    extract_and_update_excel(response_data, output_path, awbcode)
                    print(response_data)
                    return response_data
                else:
                    time.sleep(5)
            except requests.exceptions.RequestException as e:
                time.sleep(5)
        print(f"Max retries reached for AWB {awbcode}. Unable to get a valid response.")
        return None

    # 示例调用：请确保 `mawb_list` 和 `output_path` 已定义
    clear_excel_file(output_path)
    for mawb in mawb_list:
        checkstatus(token, mawb, output_path)
    delete_first_row(output_path)
    update_output_text(output_text, "操作已完成请检查master数量\n\n")

















def QP_program(account, password, output_text):
    expiration_date =expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_list}\n\n\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:
        if windowname != "task":
            print("窗口已关闭，程序终止。")  # 调试打印
            update_output_text(output_text, "窗口已关闭，程序终止。\n\n\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[4]/tbody/tr[1]/td[2]/a'
            # 等待最多 50 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"在处理 {item}时出现问题！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()









def document_program(account, password, output_text):

    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date:
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            pass
        else:
            wb = Workbook()
            wb.save(file_path)
            sys.exit()
    else:
        sys.exit()

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):

        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")
        try:

            # 点击图片（如果非绿标的情况下）
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            img_element = driver.find_element(By.XPATH, img_xpath)

            # 用WebElement传入move_to_element
            ActionChains(driver).move_to_element(img_element).perform()
            time.sleep(1)  # 适当等待悬停触发的效果

            check_alert(driver)
            # 等待edit按钮可点击并点击（循环10秒，每秒尝试）
            timeout = 10  # 最大等待时间10秒
            interval = 1  # 每隔1秒尝试一次
            start_time = time.time()

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "//a[contains(@class,'shipment-row')]/img[@src='/images/icons/edit_30x30.png']"))
                    )
                    edit_img.click()
                    print("点击成功")
                    break  # 点击成功跳出循环
                except (ElementClickInterceptedException, TimeoutException) as e:
                    elapsed = time.time() - start_time
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        break
                    else:
                        print("点击被拦截或元素未可点，等待1秒后重试...")
                        time.sleep(interval)

        except Exception as e:
            print(f"❌ Error occurred: {e}")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False


    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'PreviewInvoice')]"))
        ).click(), "点击预览按钮", retries=10, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()

    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")
def release_program(account, password, output_text):

    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date and account not in premium_member:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止



    try:
        options = webdriver.ChromeOptions()
        options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        options.add_argument("--no-sandbox")  # 非root用户需要此参数
        options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)


        update_output_text(output_text, "ChromeDriver 初始化成功\n")
    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):

        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")
        try:
            # 找到目标img元素（绿标图标）

            # 点击图片（如果非绿标的情况下）
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            img_element = driver.find_element(By.XPATH, img_xpath)

            # 用WebElement传入move_to_element
            ActionChains(driver).move_to_element(img_element).perform()
            time.sleep(1)  # 适当等待悬停触发的效果

            check_alert(driver)
            # 等待edit按钮可点击并点击（循环10秒，每秒尝试）
            timeout = 10  # 最大等待时间10秒
            interval = 1  # 每隔1秒尝试一次
            start_time = time.time()

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "//a[contains(@class,'shipment-row')]/img[@src='/images/icons/edit_30x30.png']"))
                    )
                    edit_img.click()
                    print("点击成功")
                    break  # 点击成功跳出循环
                except (ElementClickInterceptedException, TimeoutException) as e:
                    elapsed = time.time() - start_time
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        break
                    else:
                        print("点击被拦截或元素未可点，等待1秒后重试...")
                        time.sleep(interval)

        except Exception as e:
            print(f"❌ Error occurred: {e}")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False


    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)



        try:
            checkbox = driver.find_element(By.ID, "IsBatchProcessing")

            # 用 JS 取消 disabled 和 checked
            driver.execute_script("""
                arguments[0].removeAttribute('disabled');
            """, checkbox)

            # 点击一下勾上

            driver.execute_script("""
                arguments[0].checked = false;
            """, checkbox)

            print("✅ 已成功解锁并勾选 checkbox")
        except Exception as e:
            print(f"❌ 解锁勾选 checkbox 失败: {e}")
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'SubmitValidatedInvoice')]"))
        ).click())
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_lista}\n\n\n")
    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")
def release_program2(account, password, output_text):

    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date and account not in premium_member:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止



    try:
        options = webdriver.ChromeOptions()
        options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        options.add_argument("--no-sandbox")  # 非root用户需要此参数
        options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)


        update_output_text(output_text, "ChromeDriver 初始化成功\n")
    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):

        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")
        try:
            # 找到目标img元素（绿标图标）

            # 点击图片（如果非绿标的情况下）
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            img_element = driver.find_element(By.XPATH, img_xpath)

            # 用WebElement传入move_to_element
            ActionChains(driver).move_to_element(img_element).perform()
            time.sleep(1)  # 适当等待悬停触发的效果

            check_alert(driver)
            # 等待edit按钮可点击并点击（循环10秒，每秒尝试）
            timeout = 10  # 最大等待时间10秒
            interval = 1  # 每隔1秒尝试一次
            start_time = time.time()

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "//a[contains(@class,'shipment-row')]/img[@src='/images/icons/edit_30x30.png']"))
                    )
                    edit_img.click()
                    print("点击成功")
                    break  # 点击成功跳出循环
                except (ElementClickInterceptedException, TimeoutException) as e:
                    elapsed = time.time() - start_time
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        break
                    else:
                        print("点击被拦截或元素未可点，等待1秒后重试...")
                        time.sleep(interval)

        except Exception as e:
            print(f"❌ Error occurred: {e}")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False


    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)



        # try:
        #     # checkbox = driver.find_element(By.ID, "IsBatchProcessing")
        #
        #     # 用 JS 取消 disabled 和 checked
        #     # driver.execute_script("""
        #     #     arguments[0].removeAttribute('disabled');
        #     # """, checkbox)
        #
        #     # 点击一下勾上
        #
        #     driver.execute_script("""
        #         arguments[0].checked = false;
        #     """, checkbox)
        #
        #     print("✅ 已成功解锁并勾选 checkbox")
        # except Exception as e:
        #     print(f"❌ 解锁勾选 checkbox 失败: {e}")
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'SubmitValidatedInvoice')]"))
        ).click())
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_lista}\n\n\n")
    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")
def bolupdate_program(account, password, output_text):

    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):
        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")

        try:
            # 检查 iframe
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            print(f"🔎 检测到 {len(iframes)} 个 iframe")
            iframe_switched = False
            if iframes:
                for i, iframe in enumerate(iframes):
                    try:
                        driver.switch_to.frame(iframe)
                        print(f"✅ 切换到 iframe {i}")
                        driver.find_element(By.XPATH,
                                            "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                        print("✅ 悬停元素在 iframe 中")
                        iframe_switched = True
                        break
                    except:
                        driver.switch_to.default_content()
                        print(f"❌ iframe {i} 中无目标元素，切换回主页面")
            else:
                print("✅ 无 iframe")

            # 定位悬停元素并提取 <td> 的 id
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            print(f"🔍 尝试定位悬停元素: {img_xpath}")
            img_elements = driver.find_elements(By.XPATH, img_xpath)
            print(f"🔎 找到 {len(img_elements)} 个悬停元素")
            if len(img_elements) > 1:
                print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                for i, elem in enumerate(img_elements):
                    print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
            img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
            print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

            # 获取父 <td> 的 id
            td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
            td_id = td_element.get_attribute("id")
            print(f"✅ 找到父 <td> id: {td_id}")

            # 悬停并等待菜单加载
            ActionChains(driver).move_to_element(img_element).perform()
            print("✅ 已执行悬停操作")
            try:
                WebDriverWait(driver, 5).until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                )
                print("✅ 菜单已加载")
            except TimeoutException:
                print("❌ 菜单未加载，可能悬停失败")

            # 检查弹窗
            def check_alert(driver):
                try:
                    alert = driver.switch_to.alert
                    alert.accept()
                    print("✅ 已关闭弹窗")
                except:
                    print("✅ 无弹窗")

            check_alert(driver)

            # 检查高 z-index 元素
            overlays = driver.find_elements(By.XPATH,
                                            "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
            print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
            for overlay in overlays[:3]:
                print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

            # 定位 Edit 按钮，使用父 <td> 的 id 约束
            timeout = 10
            interval = 1
            start_time = time.time()
            edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
            print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
            if len(edit_elements) > 1:
                print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
            elif len(edit_elements) == 0:
                print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                print(
                    "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                edit_elements = driver.find_elements(By.XPATH,
                                                     "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, edit_xpath))
                    )
                    print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                    print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                    try:
                        edit_img.click()
                        print("✅ 点击 Edit 按钮成功")
                        break
                    except ElementClickInterceptedException as e:
                        print(f"❌ 点击被拦截: {e}")
                        print("🔍 尝试 JavaScript 点击")
                        driver.execute_script("arguments[0].click();", edit_img)
                        print("✅ 使用 JavaScript 点击 Edit 按钮")
                        break
                except TimeoutException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ TimeoutException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                        else:
                            print("🔎 Edit 按钮未在 DOM 中找到")
                        break
                    else:
                        print("❌ 元素未可点，等待1秒后重试...")
                        time.sleep(interval)
                except ElementClickInterceptedException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ ElementClickInterceptedException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                        break
                    else:
                        print("❌ 元素被拦截，等待1秒后重试...")
                        time.sleep(interval)

            # 切换回主页面
            if iframe_switched:
                driver.switch_to.default_content()
                print("✅ 切换回主页面")

        except Exception as e:
            print(f"❌ 发生错误: {e}")
            print("📄 当前页面 HTML（部分）:")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            if edit_elements:
                print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
            else:
                print("🔎 Edit 按钮未找到")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False


    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'UpdateACEBOL')]"))
        ).click())
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_lista}\n\n\n")
    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")

def BBC_House(account, password, output_text):
    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date and account not in premium_member:
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, '找到bbcreview，马上运行\n')
            pass
        else:
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, '没能找到bbcreview，已创建，再次点击开始运行代码\n')

            sys.exit()
    else:
        sys.exit()
        update_output_text(output_text,'未能找到bbcreview 且未能创建excel，gg了\n')

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        """
        等待任何 .blockUI.blockMsg 开头的遮罩层（如 blockElement 或 blockPage）完全消失
        """
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找所有匹配的遮罩层（可能多个）
                elements = driver.find_elements(By.CSS_SELECTOR, "div.blockUI.blockMsg")
                visible_elements = [el for el in elements if el.is_displayed()]

                if visible_elements:
                    print(f"⏳ 检测到 {len(visible_elements)} 个遮罩层，等待中...")
                    time.sleep(check_interval)
                else:
                    print("✅ 所有遮罩层已隐藏")
                    return
            except (NoSuchElementException, StaleElementReferenceException):
                print("✅ 遮罩层不存在或已被移除")
                return
        print("❌ 等待超时，遮罩层仍未消失")



    def open_entry(driver):
        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")

        try:
            img_xpaths = [
                "//td[7]//img[contains(@src, '/images/icons/')]",  # 通用
                "//table//tr[1]//td[7]//img",  # 第1行
                "//tr//td[7]//ul/li/span/img",
                "//td[contains(@id, 'EntrySummary')]//img[contains(@src, '/images/icons/')]"
                # 所有第7列img
            ]

            img_element = None
            max_attempts = 2
            for attempt in range(max_attempts):
                for path in img_xpaths:
                    try:
                        img_element = driver.find_element(By.XPATH, path)
                        print(f"✅ 尝试第 {attempt + 1} 次，找到图标（XPath: {path}）")
                        break
                    except:
                        continue
                if img_element:
                    break
                else:
                    print(f"🔁 第 {attempt + 1} 次未找到图标，准备重试...")
                    time.sleep(1)

            if not img_element:
                print("❌ 所有尝试都未找到图标")
                return

            # 悬停触发 edit 图标出现
            ActionChains(driver).move_to_element(img_element).perform()
            time.sleep(1)
            check_alert(driver)

            # 点击 edit 按钮
            timeout = 10
            interval = 1
            start_time = time.time()

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((
                            By.XPATH,
                            "//a[contains(@class,'shipment-row')]/img[contains(@src,'edit_30x30.png')]"
                        ))
                    )
                    edit_img.click()
                    print("✅ 点击成功 edit 按钮")
                    break
                except (ElementClickInterceptedException, TimeoutException):
                    if time.time() - start_time >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        break
                    print("🔁 Edit 按钮未可点，重试中...")
                    time.sleep(interval)

        except Exception as e:
            print(f"❌ open_entry 失败: {e}")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        """执行一个动作，动作前后都检测并处理 alert，支持失败后自动重试"""
        wait_for_block_to_disappear(driver, timeout=40, check_interval=0.5)
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    print(f"🔁 准备重试 {description}...")
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False



    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def file_edit(file_path, results_dict):
        wb = openpyxl.load_workbook(file_path)
        ws = wb.active

        def find_first_empty_row_from_col(ws, start_col=5):
            max_check_rows = ws.max_row + 100  # 最多检查100行
            for row in range(1, max_check_rows):
                if all(ws.cell(row=row, column=col).value in [None, ""] for col in range(start_col, start_col + 20)):
                    return row
            return ws.max_row + 1

        current_row = find_first_empty_row_from_col(ws, start_col=5)

        for entry_list in results_dict.values():
            for entry in entry_list:
                # 第5列 line 字段清洗 → 提取 of 后数字
                raw_line = entry.get("line", "")
                match = re.search(r"of\s+(\d+)", raw_line)
                entry["line"] = match.group(1) if match else raw_line  # 保留数字

                # 第8列 port1 字段清洗 → 提取最后数字
                raw_port1 = entry.get("port1", "")
                if "-" in raw_port1:
                    entry["port1"] = raw_port1.split("-")[-1].strip()
                else:
                    entry["port1"] = raw_port1

                # 写入清洗后的值，从第5列开始写
                values = list(entry.values())
                for i, value in enumerate(values):
                    ws.cell(row=current_row, column=5 + i, value=value)
                current_row += 1

        wb.save(file_path)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    results_dict = {}

    def page_viewd(driver, house):
        result = []
        data_dict = {}
        try:
            try:
                iframe = driver.find_element(By.ID, "iframeInvoices")
                driver.switch_to.frame(iframe)
            except:
                pass
            success = wait_for_autocomplete(driver,
                                            "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/a[2]",
                                            0.5, 8.0)

            if success:
                line_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/form/div/div/fieldset/div/div/div[2]/div[2]/div[1]"
                importer_xpath = "/html/body/form/div[3]/div[2]/div[1]/div/fieldset/div[1]/input"
                qty_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[4]/input"
                port1_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[4]/input"
                port2_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[16]/input"
                paytype_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[16]/input"
                remote_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[2]/div/div/div/table/tbody/tr[2]/td[1]/div/input"
                house_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[3]/input"
                statementdate_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[4]/div[8]/input"
                try:
                    data_dict['line'] = driver.find_element(By.XPATH, line_xpath).text.strip()
                except:
                    data_dict['line'] = ""

                try:
                    data_dict['importer'] = driver.find_element(By.XPATH, importer_xpath).get_attribute("value").strip()
                except:
                    data_dict['importer'] = ""

                try:
                    data_dict['qty'] = driver.find_element(By.XPATH, qty_xpath).get_attribute("value").strip()
                except:
                    data_dict['qty'] = ""

                try:
                    data_dict['port1'] = driver.find_element(By.XPATH, port1_xpath).get_attribute("value").strip()
                except:
                    data_dict['port1'] = ""

                try:
                    data_dict['port2'] = driver.find_element(By.XPATH, port2_xpath).get_attribute("value").strip()
                except:
                    data_dict['port2'] = ""

                try:
                    data_dict['paytype'] = driver.find_element(By.XPATH, paytype_xpath).get_attribute("value").strip()
                except:
                    data_dict['paytype'] = ""

                try:
                    checkbox_element = driver.find_element(By.XPATH, remote_xpath)
                    data_dict['remote_checked'] = checkbox_element.is_selected()
                except:
                    data_dict['remote_checked'] = False

                try:
                    data_dict['house'] = driver.find_element(By.XPATH, house_xpath).get_attribute("value").strip()
                except:
                    data_dict['house'] = ""

                try:
                    data_dict['statementdate'] = driver.find_element(By.XPATH, statementdate_xpath).get_attribute(
                        "value").strip()
                except:
                    data_dict['statementdate'] = ""

                # 把字典放进列表
                result.append(data_dict)

                click_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/a[2]"
                btn = driver.find_element(By.XPATH, click_xpath)
                btn.click()

                # 提取 SCAC, QTR, UOM 的三个输入框内容
                scac_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[2]/input"
                qtr_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[4]/input"
                uom_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[5]/input"

                scac = driver.find_element(By.XPATH, scac_xpath).get_attribute('value')
                qtr = driver.find_element(By.XPATH, qtr_xpath).get_attribute('value')
                uom = driver.find_element(By.XPATH, uom_xpath).get_attribute('value')

                # 用三个值填入表单
                input_1_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[2]/input"
                input_2_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[3]/input"
                input_3_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[4]/input"
                input_4_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[5]/input"
                data_entry(driver, input_1_xpath, "/html/body/ul[24]/li[1]/div", 0.5, 8.0, scac)

                normal_entry(driver, input_2_xpath, 0.5, 8.0, house)
                normal_entry(driver, input_3_xpath, 0.5, 8.0, qtr)
                data_entry(driver, input_4_xpath, "/html/body/ul[25]/li[1]/div", 0.5, 8.0, uom)
                return result

            else:
                return None
                print("元素未加载成功，跳过处理。")

        except Exception as e:
            return None
            print("发生异常:", e)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列
    c_column = df.iloc[:, 2]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    filtered_listc = c_column[c_column.notna() & (c_column != 'na')].tolist()
    print(filtered_listc)

    results_dict = {}
    wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
    # open_entry(driver)
    # wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    for entry_number, house in zip(filtered_lista, filtered_listc):
        update_output_text(output_text, f"正在处理{entry_number}\n")
        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")
        info_text = page_viewd(driver, house)
        results_dict[entry_number] = info_text
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))).click(),
                "点击某个按钮")
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        update_output_text(output_text, f"处理已完成{entry_number}\n")
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)

        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        time.sleep(1)

    file_edit(file_path, results_dict)
    update_output_text(output_text, "文件已保存\n")


def BBC_review_program(account, password, output_text):
    data_dict = {}
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    if desktop_path:
        excel_path = os.path.join(desktop_path, "BBCform.xlsx")
        if os.path.exists(excel_path):
            update_output_text(output_text, f"找到文件：{excel_path}\n\n")
        else:
            wb = Workbook()
            wb.save(excel_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{excel_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        # 固定的阻挡元素 XPath
        xpath = "/html/body/div[2]/div[2]/div[5]"
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                element = driver.find_element(By.XPATH, xpath)
                print("Blocking element found, waiting...")
                time.sleep(check_interval)
            except NoSuchElementException:
                print("Blocking element disappeared.")
                time.sleep(1)
                return
        print("Timeout reached, element still present.")

    def extract_fda_status(pga_text, print_paragraphs=False):
        paragraphs = re.split(r'\n\s*\n', pga_text)
        line_status_map = {}

        # 状态优先级定义
        priority = {"proceed": 3, "hold": 2, "under": 1}

        for idx, p in enumerate(paragraphs, 1):
            lines = p.strip().splitlines()
            if not lines:
                continue

            # 提取 line number
            line_num_match = re.search(r'CBP Beginning Line:\s*(\d+)', lines[0])
            line_number = line_num_match.group(1) if line_num_match else "UNKNOWN"

            full_text = " ".join(lines).lower()

            # 情况 1️⃣：包含 FDA 的段落（主流程）
            if 'fda' in full_text:
                if print_paragraphs:
                    print(f"--- FDA Paragraph {idx} ---")
                    print(p.strip())
                    print()

                if "proceed" in full_text:
                    status = "proceed"
                elif "hold" in full_text:
                    status = "hold"
                elif "under" in full_text:
                    status = "under"
                else:
                    status = "unknown"

                # 按优先级记录
                if (line_number not in line_status_map) or (priority[status] > priority[line_status_map[line_number]]):
                    line_status_map[line_number] = status

            # 情况 2️⃣：不含 FDA 但含 hold
            elif "hold" in full_text:
                if print_paragraphs:
                    print(f"--- Non-FDA Hold Paragraph {idx} ---")
                    print(p.strip())
                    print()
                # 只有在这个 line 没出现在 FDA 部分时，才加入
                if line_number not in line_status_map:
                    line_status_map[line_number] = "hold"

        # 最终输出，过滤掉 UNKNOWN
        result = [f"{line}: {status}" for line, status in sorted(line_status_map.items()) if line != "UNKNOWN"]
        if not result:
            return "N/A"
        return result

    def search_entry_num(entry_number, timeout=5):
        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "//*[@id='window_0']/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                update_output_text(output_text, "成功进行搜索。\n")
                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    update_output_text(output_text, "超时，未能成功搜索，跳过此entry。\n")
                    return "超时"
                else:
                    time.sleep(1)  # 等待1秒后重试

    time.sleep(1)

    def status_check():
        try:
            wait_for_block_to_disappear(driver)
            img_element = driver.find_element(
                By.XPATH,
                "//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img"
            )
            img_src = img_element.get_attribute("src")
            return img_src
            # 检查是否包含 green-status


        except:
            return "N/A"
    def get_invoice():
        try:
            wait_for_block_to_disappear(driver)
            invoice_element = driver.find_element(By.XPATH,
                                              "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[1]/td[2]")

            invoice_text = invoice_element.text

            return invoice_text
            # 检查是否包含 green-status


        except:
            return "N/A"
    def pga_check():
        try:
            # 打开目标网页
            img_element = driver.find_element(By.XPATH,
                                              "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr/td[25]/div/span/a/img")

            img_src = img_element.get_attribute("src")

            if "green-status" in img_src:
                print("The image is a green status icon.")
                return "N/A", "N/A", "N/A"
            else:
                print("The image is not a green status icon.")
                img_element.click()
                wait_for_block_to_disappear(driver)
                time.sleep(1)

                base_xpath = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[2]/td/div/table/tbody"
                pga_form_xpath = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[2]/td/div"
                pga_form_element = driver.find_element(By.XPATH, pga_form_xpath)
                pga_text = pga_form_element.text
                WebDriverWait(driver, 30).until(EC.presence_of_element_located((By.XPATH, base_xpath)))
                first_column_data = []
                print("Starting to look for rows...")
                row_number = 1
                while True:
                    try:
                        row_xpath = f"{base_xpath}/tr[{row_number}]/td[2]"
                        main_cell = driver.find_element(By.XPATH, row_xpath)

                        if "DATA UNDER PGA REVIEW" in main_cell.text:
                            nested_table_xpath = f"{base_xpath}/tr[{row_number}]/td[2]/table"
                            nested_rows = driver.find_elements(By.XPATH, nested_table_xpath + "/tbody/tr")

                            for nested_row in nested_rows:
                                third_column = nested_row.find_element(By.XPATH, "./td[3]").text.strip()
                                if "DATA UNDER PGA REVIEW" in third_column:
                                    first_column = nested_row.find_element(By.XPATH, "./td[1]").text.strip()
                                    if first_column:
                                        first_column_data.append(first_column)

                        row_number += 1

                        foocheck = extract_fda_status(pga_text, print_paragraphs=False)




                    except Exception as e:
                        break

                return img_src, " ".join(first_column_data), foocheck

        except Exception as e:
            print(f"Error occurred: {e}")
            return "N/A", "N/A", "N/A"

    def entry_type_review():
        try:

            # 打开目标网页
            # 通过 XPath 找到 img 元素
            first_flag_element = driver.find_element(By.XPATH,
                                                     "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[1]/td[7]/div/ul/li/span/img")

            # 获取 src 属性
            img_src = first_flag_element.get_attribute("src")
            print(f"Image src: {img_src}")
            time.sleep(1)
            # 检查是否包含 green-status
            if "gree" in img_src:
                print("The image is a green status icon.")
            else:
                update_output_text(output_text, "旗帜并非绿色。\n")
                img_xpath = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[1]/td[7]/div/ul/li/span/img"
                abi_status_xpath = "//div[@class='thumbn' and contains(., 'ABI STATUS')]/a"
                driver.find_element(By.XPATH, img_xpath).click()
                update_output_text(output_text, "已打开状态栏。\n")

                # WebDriverWait(driver, 60).until(
                #     EC.element_to_be_clickable((By.XPATH, abi_status_xpath))
                # ).click()

                time.sleep(1)
                first_column = []
                third_column = []
                base_xpath = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[2]/td/div"

                WebDriverWait(driver, 30).until(
                    EC.presence_of_element_located((By.XPATH, base_xpath))
                )

                # 存储提取的数据
                first_column = []
                third_column = []

                # 第一个表格
                row_xpath_1 = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[2]/td/div/div[1]/table/tbody/tr[1]/td[2]/table/tbody/tr"
                nested_rows = driver.find_elements(By.XPATH, row_xpath_1)
                total_rows = len(nested_rows)

                for index, nested_row in enumerate(nested_rows, start=1):
                    tds = nested_row.find_elements(By.TAG_NAME, "td")
                    if len(tds) >= 3:
                        first_value = tds[0].text.strip()
                        third_value = tds[2].text.strip()
                        first_column.append(first_value)
                        third_column.append(third_value)

                    # 每 10 行更新一次百分比
                    if index % 10 == 0 or index == total_rows:
                        percent = (index / total_rows) * 100
                        update_output_text(output_text, f"{percent:.0f}%")

                # 第二个表格
                row_xpath_2 = "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[2]/div[2]/div[2]/div[3]/table/tbody/tr[2]/td/div/table/tbody/tr[1]/td[2]/table/tbody/tr"
                nested_rows = driver.find_elements(By.XPATH, row_xpath_2)
                total_rows = len(nested_rows)

                for index, nested_row in enumerate(nested_rows, start=1):
                    tds = nested_row.find_elements(By.TAG_NAME, "td")
                    if len(tds) >= 3:
                        first_value = tds[0].text.strip()
                        third_value = tds[2].text.strip()
                        first_column.append(first_value)
                        third_column.append(third_value)

                    if index % 10 == 0 or index == total_rows:
                        percent = (index / total_rows) * 100
                        update_output_text(output_text, f"{percent:.0f}%")
                        data_dict[entry_number] = {
                            "第一列": first_column,
                            "第三列": third_column
                        }

                data_dict[entry_number] = {"第一列": first_column, "第三列": third_column}

                output_text.insert("end", "任务完成\n")

                print(f"✅ 提取完成: {data_dict}")

        except Exception as e:
            print(f"❌ Error occurred: {e}")
            return

    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()

    # 不用 int(num)，直接用字符串
    print(filtered_list)
    update_output_text(output_text, f"即将处理：{filtered_list}\n")
    for entry_number in filtered_list:
        update_output_text(output_text, f"正在处理{entry_number}\n")

        driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
        wait_for_block_to_disappear(driver)
        search_result = search_entry_num(entry_number=entry_number)
        if search_result == "超时":
            print(f"跳过 {entry_number}，因超时未能交互")
            # 如果超时，将 "error" 作为占位符
            new_data = pd.DataFrame([{
                "entry_number": entry_number,
                "status_img_src": "error",
                "pga_img_src": "error",
                "first_column_data": "error"
            }])
            outputdf = pd.concat([outputdf, new_data], ignore_index=True)
            update_output_text(output_text, f"{entry_number}未能成功处理\n")
            continue
        wait_for_block_to_disappear(driver)

        status_img_src = status_check()  # 获取 status_check 的 img_src
        invoice_number=get_invoice()
        wait_for_block_to_disappear(driver)

        pga_img_src, first_column_data, foo_column_data = pga_check()  # 获取 pga_check 的 img_src 和 first_column_data
        if search_result != "超时":
            entry_type_review()
        wait_for_block_to_disappear(driver)

        # 构建一个新的 DataFrame 行
        new_data = pd.DataFrame([{
            "entry_number": entry_number,
            "status_img_src": status_img_src,
            "pga_img_src": pga_img_src,
            "first_column_data": " ".join(first_column_data),
            "foo_check": foo_column_data,
            "invoice_number":invoice_number
        }])

        # 使用 concat 合并数据
        outputdf = pd.concat([outputdf, new_data], ignore_index=True)
        update_output_text(output_text, f"{entry_number}处理完成\n")
        time.sleep(1)

    # 打印 outputdf 来检查结果
    print(outputdf)

    # 1. Extract the last part after '/' and remove everything after '-' for status_img_src and pga_img_src
    outputdf = pd.concat([outputdf, new_data], ignore_index=True)
    outputdf['status_img_src'] = outputdf['status_img_src'].apply(
        lambda x: x.split('/')[-1] if isinstance(x, str) else x
    )

    outputdf['pga_img_src'] = outputdf['pga_img_src'].apply(
        lambda x: x.split('/')[-1] if isinstance(x, str) and x != 'N/A' else x
    )

    # 2. Modify first_column_data to remove all spaces and add a space before each '#'
    outputdf['first_column_data'] = outputdf['first_column_data'].str.replace(" ", "")

    # Print the result to check
    print(outputdf)
    with pd.ExcelWriter(excel_path, engine="openpyxl") as writer:
        # 清空原文件
        with open(excel_path, "w") as f:
            f.truncate(0)

        # 写入主表
        outputdf.to_excel(writer, index=False, sheet_name="Main")

        # 生成子表
        for key, value in data_dict.items():
            # 创建 DataFrame
            df = pd.DataFrame({
                "第一列": value["第一列"],
                "第三列": value["第三列"]
            })
            # 写入子表，子表名为键名
            df.to_excel(writer, index=False, sheet_name=key)
    print(data_dict)
    update_output_text(output_text, "文件保存成功")

    wb = openpyxl.load_workbook(excel_path)

    # 定义绿色填充样式
    green_fill = PatternFill(start_color="00FF00", end_color="00FF00", fill_type="solid")
    keywords = ["ACTN", "accepted", "may"]

    # 遍历所有子表
    for sheet in wb.worksheets:
        # 逆序遍历行，避免删除时行号错乱
        for row_idx in range(sheet.max_row, 0, -1):
            second_col_value = sheet.cell(row=row_idx, column=2).value
            second_col_value = str(second_col_value).strip() if second_col_value else ""

            if any(re.search(keyword, second_col_value, re.IGNORECASE) for keyword in keywords):
                sheet.delete_rows(row_idx, 1)

    wb.save(excel_path)

def transmit_program(account, password, output_text):
    expiration_date = expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要处理的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:
        if windowname != "task":
            print("窗口已关闭，程序终止。")  # 调试打印
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[2]/table[5]/tbody/tr[1]/td[2]/input'

            # 等待最多 50 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素 {item} 的按钮！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()
def hold_program(account, password, output_text, inputnum):
    global windowname
    expiration_date = expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "找hold.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None,dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列
    c_column = df.iloc[:, 2]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()

    filtered_listc = c_column.dropna().apply(
        lambda x: int(x) if isinstance(x, (int, float)) and x == int(x) else x).tolist()

    # 打印结果
    update_output_text(output_text, filtered_list)
    update_output_text(output_text, "\n\n")  # 添加两个换行符
    update_output_text(output_text, filtered_listc)
    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")


        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = "https://www.netchb.com/app/inbond/inbondMenu.do?itNo=862326905"
    driver.get(target_url)

    current_title = driver.title
    current_frame = tk.Frame(root)
    current_frame.pack()
    print(windowname)
    if inputnum == "仅查找":
        for itNo in filtered_list:
            # 调试打印
            if windowname != "task":
                print("窗口已关闭，程序终止。")  # 调试打印
                update_output_text(output_text, "窗口已关闭，程序终止。\n")
                sys.exit()  # 窗口已关闭，退出程序

            target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={itNo}"
            driver.get(target_url)

            try:
                # 等待表格加载
                wait = WebDriverWait(driver, 10)
                table_body = wait.until(
                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                )

                for b_element in filtered_listc:
                    # if (itNo, b_element) in found_records:
                    #     continue  # 跳过已找到的 filterb

                    try:
                        # 查找包含 b_element 的元素
                        record_element = table_body.find_element(By.XPATH, f".//*[contains(text(), '{b_element}')]")

                        update_output_text(output_text, f"找到匹配项: {itNo} - {b_element}")

                    except NoSuchElementException:
                        continue  # 未找到 b_element，继续找下一个

            except Exception as e:
                update_output_text(output_text, f"错误发生在 {itNo}: {e}")
        time.sleep(0.5)
        update_output_text(output_text, f"匹配结果: {000}")
    if inputnum == "删除":

        found_records = []
        for itNo in filtered_list:
            if windowname != "task":
                update_output_text(output_text, "窗口已关闭，程序终止。\n")
                sys.exit()  # 窗口已关闭，退出程序

            target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={itNo}"
            driver.get(target_url)

            try:
                # 等待表格加载
                wait = WebDriverWait(driver, 10)
                table_body = wait.until(
                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                )

                rows = table_body.find_elements(By.XPATH, ".//tr")  # 获取所有行

                for b_element in filtered_listc:
                    # if (itNo, b_element) in found_records:
                    #     continue  # 跳过已找到的 filterb

                    try:
                        record_element = table_body.find_element(By.XPATH, f".//*[contains(text(), '{b_element}')]")
                    except NoSuchElementException:
                        continue  # 没找到直接跳过

                    b_element_str = str(b_element)  # 转换 b_element 为字符串
                    found_in_row = False  # 标记是否找到匹配项

                    for idx, row in enumerate(rows, start=1):
                        cell_elements = row.find_elements(By.XPATH, ".//td")
                        for cell in cell_elements:
                            if b_element_str in str(cell.text):  # 强制转换 cell.text 进行匹配
                                found_records.append((itNo, b_element))  # 记录已找到

                                delete_button_xpath = f'/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[{idx}]/td[5]/input'
                                abutton_xpath = f'/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[{idx}]/td[2]'

                                try:
                                    delete_button = WebDriverWait(driver, 5).until(
                                        EC.element_to_be_clickable((By.XPATH, delete_button_xpath))
                                    )

                                except Exception as e:
                                    continue  # 如果找不到 delete_button，则跳过当前行

                                try:
                                    button_element = driver.find_element(By.XPATH, abutton_xpath)
                                    update_output_text(output_text, f"{itNo}中的{button_element.text}")


                                except NoSuchElementException:
                                    continue  # 如果找不到 abutton，则跳过当前行

                                delete_button.click()
                                time.sleep(0.5)

                                try:
                                    alert = driver.switch_to.alert  # 获取当前弹窗
                                    alert.accept()  # 点击确认按钮
                                    time.sleep(0.5)
                                    update_output_text(output_text, "成功删除")
                                except NoAlertPresentException:
                                    pass

                                # 删除后重新获取 table_body 和 rows
                                table_body = wait.until(
                                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                                )
                                rows = table_body.find_elements(By.XPATH, ".//tr")  # 重新获取所有行

                                found_in_row = True
                                break  # 跳出当前行处理
                        if found_in_row:
                            break  # 退出外层循环
            except Exception as e:
                continue  # 如果发生错误，继续处理下一个记录
        time.sleep(0.5)
        update_output_text(output_text, "匹配结果:", found_records)

    update_output_text(output_text, current_title)
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def statuschange_program(account, password, output_text):
    expiration_date = expiration_date1
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    # 当前时间
    now = datetime.datetime.now()

    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要处理的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:

        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序

        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理 {item}")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[10]/td[2]/a'

            # 等待最多 20 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

            # 等待新页面加载完成
            select_xpath = '//*[@id="changeInbondStatusTo"]'
            select_element = WebDriverWait(driver, 20).until(
                EC.presence_of_element_located((By.XPATH, select_xpath))
            )

            # 使用 Select 类选择 "Accepted" 选项
            select = Select(select_element)
            select.select_by_value("ACCEPTED")  # 使用 value 属性选择 "Accepted"

            update_output_text(output_text, f"Successfully selected 'Accepted' for {item}.")

            button_xpath = '//*[@id="changeInbondStatusButton"]'
            target_button = WebDriverWait(driver, 20).until(
                EC.element_to_be_clickable((By.XPATH, button_xpath))
            )
            target_button.click()
            update_output_text(output_text, f"Successfully clicked the target button for {item}.")

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素或发生错误 {item}！错误: {e}")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()
def del_program(account, password, output_text):
    expiration_date = expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目

    for item in filtered_list:
        if windowname!= "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[8]/td[2]/a'

            # 等待最多 20 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()
            try:
                # 查找特定的元素，增加最长等待时间
                element_xpath = '/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr[2]/td/input'

                # 等待最多 20 秒，直到元素可点击
                element = WebDriverWait(driver, 50).until(
                    EC.element_to_be_clickable((By.XPATH, element_xpath))
                )

                # 如果元素存在并且可点击，点击它
                element.click()


            except Exception as e:
                update_output_text(output_text, f"点击确认按钮时出错：{e}\n")

                # 如果元素未找到或不可点击，打印消息

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素 {item} 的按钮！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()
def delallinbond_program(account, password, output_text):
    expiration_date = expiration_date1

    # 当前时间
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n")
        input("按 Enter 键退出...")
        exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目

    for item in filtered_list:
        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        try:
            # 等待页面加载
            wait = WebDriverWait(driver, 10)
            table_body = wait.until(
                EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
            )

            while True:
                try:
                    # 查找删除按钮并点击
                    delete_button = driver.find_element(By.XPATH,
                                                        '/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[4]/td[5]/input')
                    delete_button.click()
                    time.sleep(0.5)

                    # 处理弹窗
                    try:
                        alert = driver.switch_to.alert  # 正确方式，直接访问 alert
                        alert.accept()  # 点击确认按钮
                        time.sleep(0.5)
                    except NoAlertPresentException:
                        update_output_text(output_text, f"没有弹窗，跳过弹窗处理。")

                except NoSuchElementException:
                    update_output_text(output_text, f"元素 {filter} 的删除按钮不存在，退出循环。")

                    break

        except Exception as e:
            update_output_text(output_text, f"错误发生在 {filter}: {e}")
def headeredit_program(account, password, output_text,inputnum):
    expiration_date = expiration_date1
    now = datetime.datetime.now()
    update_output_text(output_text, f"过期日期：{expiration_date1}。\n\n")
    if now > expiration_date:
        update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
        exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    if desktop_path:
        excel_path = os.path.join(desktop_path, "headeredit.xlsx")
        if os.path.exists(excel_path):
            update_output_text(output_text, f"找到文件：{excel_path}\n\n")
        else:
            wb = Workbook()
            wb.save(excel_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{excel_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    if inputnum not in ["61", "63"]:
        update_output_text(output_text, "无效输入，请输入61或63！\n\n")
        exit()

    try:
        workbook = openpyxl.load_workbook(excel_path)
        sheet = workbook.active
    except Exception as e:
        update_output_text(output_text, f"无法打开Excel文件：{e}\n\n")
        exit()

    if inputnum == "63":
        editdate = sheet["B2"].value or "N/A"
        editcarrier = sheet["B3"].value or "N/A"
        editvessel = sheet["B4"].value or "N/A"
        editdestination = sheet["B5"].value or "N/A"
        editvoyage = sheet["B6"].value or "N/A"
        presentation_port = sheet["B7"].value or "N/A"
        port_of_unlading = sheet["B8"].value or "N/A"
        consigned_to_port = sheet["B9"].value or "N/A"
        goodnow = "N/A"
        CarrierID = sheet["B10"].value or "N/A"
        Entrytype = str(sheet["B11"].value or "N/A")
        Lastfp = "N/A"
    elif inputnum == "61":
        editdate = sheet["I2"].value or "N/A"
        editcarrier = sheet["I3"].value or "N/A"
        editvessel = sheet["I4"].value or "N/A"
        goodnow = sheet["I5"].value or "N/A"
        editvoyage = sheet["I6"].value or "N/A"
        presentation_port = sheet["I7"].value or "N/A"
        port_of_unlading = sheet["I8"].value or "N/A"
        consigned_to_port = sheet["I9"].value or "N/A"
        editdestination = "N/A"
        CarrierID = sheet["I10"].value or "N/A"
        Entrytype = str(sheet["I12"].value or "N/A")
        Lastfp = sheet["I11"].value or "N/A"

    update_output_text(output_text, "提取的数据如下：\n")
    update_output_text(output_text, f"日期: {editdate}\n")
    update_output_text(output_text, f"承运人: {editcarrier}\n")
    update_output_text(output_text, f"船舶: {editvessel}\n")
    update_output_text(output_text, f"目的地: {editdestination}\n")
    update_output_text(output_text, f"GNA: {goodnow}\n")
    update_output_text(output_text, f"航次: {editvoyage}\n")
    update_output_text(output_text, f"Presentation Port: {presentation_port}\n")
    update_output_text(output_text, f"Port of Unlading: {port_of_unlading}\n")
    update_output_text(output_text, f"Consigned to Port: {consigned_to_port}\n")
    update_output_text(output_text, f"carrierid: {CarrierID}\n")
    update_output_text(output_text, f"entrytype: {Entrytype}\n")
    update_output_text(output_text, f"Lastfp: {Lastfp}\n\n")

    df = pd.read_excel(file_path, header=None, dtype=str)
    a_column = df.iloc[:, 0]
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")



        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()

    values_to_update = {
        '//*[@id="pDate"]': editdate,
        '//*[@id="dImp"]': editdate,
        '//*[@id="ed"]': editdate,
        '//*[@id="ad"]': editdate,
        '//*[@id="impC"]': editcarrier,
        '//*[@id="vn"]': editvessel,
        '//*[@id="forDest"]': editdestination,
        '//*[@id="vNo"]': editvoyage,
        '//*[@id="gna"]': goodnow,
        '//*[@id="presPort"]': presentation_port,
        '//*[@id="pu"]': port_of_unlading,
        '//*[@id="usp"]': consigned_to_port,
        '//*[@id="ci"]': CarrierID,
        '//*[@id="lfp"]': Lastfp
    }
    entrytype_xpath = '//*[@id="et"]'
    url = "https://www.netchb.com/app/inbond/inbondMenu.do?itNo=054302382"
    driver.get(url)
    for item in filtered_list:
        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        driver.get(target_url)

        try:
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[6]/td[2]/a'
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )
            element.click()
            time.sleep(1)

            if Entrytype != "N/A":
                try:
                    entrytype_element = WebDriverWait(driver, 20).until(
                        EC.element_to_be_clickable((By.XPATH, entrytype_xpath))
                    )
                    select = Select(entrytype_element)
                    select.select_by_value(Entrytype)
                    time.sleep(1)
                except Exception as e:
                    update_output_text(output_text, f"Error setting Entrytype at {entrytype_xpath}: {e}\n")
            else:
                update_output_text(output_text, f"Skipped setting Entrytype because value is 'N/A'.\n")

            for xpath, value in values_to_update.items():
                if value != "N/A":
                    try:
                        field_element = WebDriverWait(driver, 20).until(
                            EC.element_to_be_clickable((By.XPATH, xpath))
                        )
                        field_element.clear()
                        field_element.send_keys(value)
                    except Exception as e:
                        update_output_text(output_text, f"Error updating field at {xpath}: {e}\n")
                else:
                    update_output_text(output_text, f"Skipped updating field at {xpath} because value is 'N/A'.\n")

            time.sleep(2)

            save_xpath = '//*[@id="inbondHeaderForm"]/input[4]'
            saveelement = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, save_xpath))
            )
            saveelement.click()

        except Exception as e:
            update_output_text(output_text, f"Error occurred for {item}: {e}\n")

        target_url2 = f"https://www.netchb.com/app/home.do"
        driver.get(target_url2)
        time.sleep(4)

    input("Press Enter to close the browser...")
    driver.quit()
import customtkinter as ctk
from tkinter import messagebox
import threading

ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# 用于停止线程的事件
stop_event = threading.Event()


def start_program(account, password, output_text, task_type, mode=None):
    stop_event.clear()  # 清除停止事件，准备开始任务
    if task_type == "QP":
        QP_program(account, password, output_text)
    if task_type == "inbond提取":
        inbond_program(account, password, output_text)

    elif task_type == "Transmit":
        transmit_program(account, password, output_text)
    elif task_type == "Hold":
        hold_program(account, password, output_text, mode)
    elif task_type == "DelQP":
        del_program(account, password, output_text)
    elif task_type == "删除所有house":
        delallinbond_program(account, password, output_text)
    elif task_type == "header修改":
        headeredit_program(account, password, output_text, mode)
    elif task_type == "更改状态accept":
        statuschange_program(account, password, output_text)
    elif task_type == "BBC数据显示":
        BBC_review_program(account, password, output_text)
    elif task_type == "BBC Document":
        document_program(account, password, output_text)
    elif task_type == "BBC House":
        BBC_House(account, password, output_text)
    elif task_type == "批量放货(batch)":
        release_program(account, password, output_text)
    elif task_type == "批量放货(不操作)":
        release_program2(account, password, output_text)
    elif task_type == "query":
        query_program(account, password, output_text)
    elif task_type == "bolupdate":
        bolupdate_program(account, password, output_text)
    elif task_type == "reject修复(目前仅AL1,EP7)":
        rejectfix_program(account, password, output_text)


# 登录界面
def login_window():
    global windowname
    windowname = 'login'

    login_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    login_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def proceed_login():
        account = entry_account.get()
        password = entry_password.get()
        if not account or not password:
            messagebox.showerror("错误", "账号或密码不能为空！")
            return
        login_frame.destroy()
        show_main_window(account, password)

    label_account = ctk.CTkLabel(login_frame, text="账号:", font=("Arial", 16), text_color="#FFFFFF")
    label_account.pack(pady=10)
    entry_account = ctk.CTkEntry(login_frame, width=300, height=35, font=("Arial", 12), placeholder_text="请输入账号")
    entry_account.pack(pady=10)

    label_password = ctk.CTkLabel(login_frame, text="密码:", font=("Arial", 16), text_color="#FFFFFF")
    label_password.pack(pady=10)
    entry_password = ctk.CTkEntry(login_frame, width=300, height=35, show="*", font=("Arial", 12),
                                  placeholder_text="请输入密码")
    entry_password.pack(pady=10)

    login_button = ctk.CTkButton(login_frame, text="确认", command=proceed_login, width=200, height=40,
                                 corner_radius=10)
    login_button.pack(pady=20)


# 主界面
def show_main_window(account, password):
    global windowname
    main_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    main_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def switch_to_task(task_type):
        global windowname
        main_frame.destroy()
        show_task_window(account, password, task_type)
        windowname = 'task'

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )


    scrollable_frame = ctk.CTkScrollableFrame(main_frame, fg_color="transparent", width=540, height=260)
    scrollable_frame.pack(pady=20, padx=10, fill="both", expand=True)

    buttons = [
        ("QP", lambda: switch_to_task("QP")),
        ("Transmit", lambda: switch_to_task("Transmit")),
        ("Hold", lambda: switch_to_task("Hold")),
        ("DelQP", lambda: switch_to_task("DelQP")),
        ("删除所有house", lambda: switch_to_task("删除所有house")),
        ("header修改", lambda: switch_to_task("header修改")),
        ("更改状态accept", lambda: switch_to_task("更改状态accept")),
        ("BBC数据显示", lambda: switch_to_task("BBC数据显示")),
        ("BBC Document", lambda: switch_to_task("BBC Document")),
        ("BBC House", lambda: switch_to_task("BBC House")),
        ("梦想成真模拟器", lambda: switch_to_task("梦想成真模拟器")),
        ("批量放货(batch)", lambda: switch_to_task("批量放货(batch)")),
        ("批量放货(不操作)", lambda: switch_to_task("批量放货(不操作)")),
        ("query", lambda: switch_to_task("query")),
        ("bolupdate", lambda: switch_to_task("bolupdate")),
        ("reject修复(目前仅AL1,EP7)", lambda: switch_to_task("reject修复(目前仅AL1,EP7)")),
        ("inbond提取", lambda: switch_to_task("inbond提取")),

    ] + [("未解锁功能", None)] * 9  # 增加点按钮以便显示滚动效果

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )

    for i in range(9):  # 行
        for j in range(3):  # 列
            idx = i * 3 + j
            if idx < len(buttons):
                btn_text, btn_cmd = buttons[idx]
                btn = btn = create_button(scrollable_frame, btn_text, btn_cmd)
                btn.grid(row=i, column=j, padx=10, pady=10)
# 任务界面
def show_task_window(account, password, task_type):
    task_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    task_frame.pack(padx=20, pady=20, fill="both", expand=True)

    output_text = ctk.CTkTextbox(
        task_frame, width=520, height=120, font=("Consolas", 11),
        fg_color="#1e1e1e", text_color="#FFFFFF", corner_radius=10,
        border_width=2, border_color="#007acc"
    )
    output_text.pack(pady=10)

    if task_type == "Hold" or task_type == "header修改" :
        mode_var = ctk.StringVar()

        mode_label = ctk.CTkLabel(task_frame, text="请选择操作模式：", text_color="white")
        mode_label.pack()

        if task_type == "Hold":
            mode_var.set("仅查找")
            mode_dropdown = ctk.CTkOptionMenu(
                task_frame,
                variable=mode_var,
                values=["仅查找", "删除"],
                width=120
            )
        elif task_type == "header修改":
            mode_var.set("61")
            mode_dropdown = ctk.CTkOptionMenu(
                task_frame,
                variable=mode_var,
                values=["61", "63"],
                width=120
            )

        mode_dropdown.pack(pady=5)
    if task_type == "梦想成真模拟器":
        output_text.destroy()
        title_frame = ctk.CTkFrame(task_frame, fg_color="transparent")
        title_frame.pack(pady=30)

        dream_label1 = ctk.CTkLabel(title_frame, text="梦", text_color="#FF69B4",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label1.pack(side="left")
        dream_label2 = ctk.CTkLabel(title_frame, text="想", text_color="#00BFFF",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label2.pack(side="left")
        rest_label = ctk.CTkLabel(title_frame, text="成真模拟器", text_color="#FFFFFF",
                                  font=("Comic Sans MS", 26, "bold"))
        rest_label.pack(side="left")

        def transform_dreams():
            progress_win = Toplevel(root)
            progress_win.title("梦想成真中")
            progress_win.geometry("400x150")
            progress_win.configure(bg="white")

            label = tk.Label(progress_win, text="梦想成真中...", font=("Arial", 14), bg="white")
            label.pack(pady=10)

            progress_bar = ttk.Progressbar(progress_win, length=300, mode='determinate')
            progress_bar.pack(pady=10)
            progress_bar["value"] = 0

            def update_bar():
                for i in range(101):
                    progress_bar["value"] = i
                    label.config(text=f"梦想成真中... {i}%")
                    time.sleep(0.05)
                    progress_win.update_idletasks()

                label.config(text="🎉 梦想已成真 🎉")

                # ✅ 达到 100% 时立即替换文字
                def replace_text(widget):
                    try:
                        if hasattr(widget, "cget") and callable(widget.cget):
                            if "text" in widget.keys():
                                text = widget.cget("text")
                                if text:
                                    new_text = text.replace("梦想", "真的").replace("梦", "真").replace("想", "的")
                                    widget.configure(text=new_text)
                    except:
                        pass
                    for child in widget.winfo_children():
                        replace_text(child)

                replace_text(task_frame)

                # ✅ 自动 1 秒后关闭进度窗口
                time.sleep(1)
                progress_win.destroy()

            threading.Thread(target=update_bar, daemon=True).start()

        dream_button = ctk.CTkButton(
            task_frame,
            text="点击把梦想变成真的",
            command=transform_dreams,
            width=250,
            height=60,
            corner_radius=15,
            font=("Comic Sans MS", 18, "bold"),
            fg_color="#FF69B4",
            hover_color="#FF1493"
        )
        dream_button.pack(pady=40)

        back_button = ctk.CTkButton(task_frame, text="返回",
                                    command=lambda: go_back_to_main(task_frame, account, password),
                                    width=200, height=40, corner_radius=10)
        back_button.pack(pady=20)

        return  # 不继续执行下面的通用逻辑

    def start_task():
        output_text.insert("end", f"启动 {task_type} 任务...\n")
        if task_type == "Hold" or task_type == "header修改":
            mode = mode_var.get()
            threading.Thread(target=start_program, args=(account, password, output_text, task_type, mode),
                             daemon=True).start()
        else:
            threading.Thread(target=start_program, args=(account, password, output_text, task_type),
                             daemon=True).start()

    start_button = ctk.CTkButton(task_frame, text="开始任务", command=start_task)
    start_button.pack(pady=10)

    back_button = ctk.CTkButton(task_frame, text="返回", command=lambda: go_back_to_main(task_frame, account, password),
                                width=200, height=40, corner_radius=10)
    back_button.pack(pady=20)




# 返回主界面并停止任务
def go_back_to_main(current_frame, account, password):
    global windowname
    print("销毁当前窗口...")  # 调试打印
    current_frame.destroy()
    stop_event.set()  # 设置停止事件，通知子线程退出
    show_main_window(account, password)
    windowname = 'main'


# 初始化主窗口
root = ctk.CTk()
root.title("还没想好名字")
root.geometry("600x420")
root.configure(fg_color="#1e1e1e")

# 显示登录窗口
login_window()

# 启动 GUI 主循环
root.mainloop()
}
